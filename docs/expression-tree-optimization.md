| Implemented | Optimization Technique          | Description                                                                                  | Pros                                                 | Cons                                                               | Pitfalls                                                                  | Preconditions                                               |
|-------------|---------------------------------|----------------------------------------------------------------------------------------------|------------------------------------------------------|--------------------------------------------------------------------|---------------------------------------------------------------------------|-------------------------------------------------------------|
| No          | **Predicate Combination**       | Merges multiple `Where` conditions into a single predicate.                                  | Reduces iterators, fewer condition checks.           | May complicate debugging and readability.                          | Complex predicates can become hard to read and maintain.                  | Requires that predicates are logically combinable.          |
| No          | **Constant Folding**            | Evaluates constant expressions at compile time.                   <br/><br/><br/><br/>       | Reduces runtime computation.                         | Limited to constant expressions.                                   | Over-optimization can lead to code obfuscation.                           | Only applicable to expressions with constant values.        |
| No          | **Dead Code Elimination**       | Removes parts of the expression tree that don't affect the final <br/><br/><br/><br/>result. | Reduces unnecessary computations.                    | May mistakenly remove necessary code if not carefully implemented. | Misidentifying dead code can cause runtime errors.                        | Requires accurate identification of dead code.              |
| No          | **Inlining**                    | Replaces simple function calls with their body expressions.       <br/><br/><br/><br/>       | Reduces function call overhead.                      | Can increase code size.                                            | Over-inlining can lead to code bloat and maintenance issues.              | Functions must be simple and used infrequently.             |
| No          | **Subexpression Elimination**   | Computes common subexpressions once and reuses results.           <br/><br/><br/><br/>       | Reduces redundant calculations.                      | Can increase memory usage if not managed properly.                 | Identifying truly common subexpressions can be challenging.               | Common subexpressions must be accurately identified.        |
| No          | **Expression Hoisting**         | Moves invariant expressions outside loops or repeated evaluations.<br/><br/><br/><br/>       | Reduces repeated computations.                       | May complicate code structure.                                     | Misidentification of invariant expressions can lead to incorrect results. | Invariant expressions must be accurately identified.        |
| No          | **Simplification Rules**        | Applies algebraic identities to simplify expressions.             <br/><br/><br/><br/>       | Simplifies expressions and reduces computations.     | Limited to known algebraic identities.                             | Over-simplification can lead to less readable code.                       | Applicable when algebraic identities are present.           |
| No          | **Short-Circuiting**            | Reorders logical conditions for optimal short-circuiting.         <br/><br/><br/><br/>       | Improves performance by reducing unnecessary checks. | Requires careful condition ordering.                               | Incorrect ordering can change logic and lead to bugs.                     | Conditions must be logically re-orderable.                  |
| No          | **Loop Unrolling**              | Unrolls loops with a known small number of iterations.            <br/><br/><br/><br/>       | Reduces loop control overhead.                       | Can increase code size.                                            | Can lead to code bloat and reduced readability.                           | Loops must have a known, small number of iterations.        |
| No          | **Conditional Simplification**  | Simplifies conditionals based on known outcomes.                  <br/><br/><br/><br/>       | Reduces unnecessary conditional checks.              | Limited to conditions with known outcomes.                         | Over-simplification can lead to loss of logic clarity.                    | Conditions must have predictable outcomes.                  |
| No          | **Operator Strength Reduction** | Replaces expensive operations with cheaper ones.                  <br/><br/><br/><br/>       | Reduces computational cost.                          | Limited to operations with cheaper alternatives.                   | May not always lead to significant performance improvements.              | Expensive operations must have viable cheaper alternatives. |
| No          | **Reassociation**               | Reorders associative operations for performance or accuracy.      <br/><br/><br/><br/>       | Improves performance and accuracy.                   | Can complicate code structure.                                     | Incorrect reassociation can lead to different results.                    | Operations must be associative.                             |
| No          | **Predicate Pushdown**          | Reorganizes predicates to apply early in the data retrieval <br/><br/><br/><br/>process.     | Reduces data retrieval overhead.                     | Can be complex to implement in some query frameworks.              | Incorrect pushdown can lead to inefficient or incorrect queries.          | Predicates must be logically pushable to data source.       |
| No          | **Index Exploitation**          | Uses index information to optimize queries.                       <br/><br/><br/><br/>       | Speeds up lookups and joins.                         | Depends on index availability and proper indexing.                 | Lack of proper indexing can negate benefits.                              | Requires knowledge of indexed fields in data source.        |
| No          | **Expression Memoization**      | Caches results of expensive expressions with unchanged inputs.    <br/><br/><br/><br/>       | Reduces redundant calculations.                      | Can increase memory usage.                                         | Cache invalidation can be complex.                                        | Expressions must have repeatable inputs and outputs.        |
